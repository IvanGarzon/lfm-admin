generator client {
  provider        = "prisma-client-js"
  output          = "./generated/client"
}

datasource db {
  provider = "postgresql"
}

generator zod {
  provider       = "prisma-zod-generator"
  output         = "./zod"
  imports        = "@/prisma/client"
  relationModel  = true
  modelCase      = "PascalCase"
  modelSuffix    = "Schema"
  useDecimalJs   = true
  prismaJsonNullability = true
}

generator json {
  provider = "prisma-json-types-generator"
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map(name: "user_id")
  type              String
  provider          String
  providerAccountId String  @map(name: "provider_account_id")
  refreshToken      String? @map(name: "refresh_token") @db.Text
  accessToken       String? @map(name: "access_token") @db.Text
  expiresAt         Int?    @map(name: "expires_at")
  tokenType         String? @map(name: "token_type")
  scope             String?
  idToken           String? @map(name: "id_token") @db.Text
  sessionState      String? @map(name: "session_state")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map(name: "accounts")
}

model User {
  id            String    @id @default(cuid())
  firstName     String    @map(name: "first_name")
  lastName      String    @map(name: "last_name")
  email         String?   @unique
  emailVerified DateTime? @map(name: "email_verified") @db.Timestamptz()
  avatarUrl     String?   @map(name: "avatar_url")
  password      String?
  accounts      Account[]
  sessions      Session[]
  taskExecutions TaskExecution[]
  QuoteStatusHistory QuoteStatusHistory[] @relation("user")
  InvoiceStatusHistory InvoiceStatusHistory[] @relation("user")

  role                  UserRole               @default(USER)
  // isTwoFactorEnabled    Boolean                @default(false)
  // twoFactorConfirmation TwoFactorConfirmation?

  @@map(name: "users")
}

model Product {
  id          String        @id @default(cuid())
  imageUrl    String?       @map(name: "image_url")
  name        String
  description String?
  status      ProductStatus @default(ACTIVE)
  price       Decimal       @default(0) @db.Decimal(15, 2)
  stock       Int           @default(0)
  createdAt   DateTime      @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt   DateTime      @default(now()) @updatedAt @map(name: "updated_at") @db.Timestamptz()
  availableAt DateTime?     @map(name: "available_at") @db.Timestamptz()

  invoiceItems InvoiceItem[]
  quoteItems   QuoteItem[]

  @@map(name: "products")
}

model Customer {
  id             String         @id @default(cuid())
  firstName      String         @map(name: "first_name")
  lastName       String         @map(name: "last_name")
  gender         Gender
  email          String         @unique
  phone          String?
  status         CustomerStatus @default(ACTIVE)
  organizationId String?        @map(name: "organization_id")
  organization   Organization?  @relation(fields: [organizationId], references: [id])
  createdAt      DateTime       @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt      DateTime       @updatedAt @map(name: "updated_at") @db.Timestamptz()
  deletedAt      DateTime?      @map(name: "deleted_at") @db.Timestamptz()

  address1         String?
  address2         String?
  city             String?
  region           String?
  postalCode       String?        @map("postal_code")
  country          String?        @default("Australia")
  lat              Float?
  lng              Float?
  formattedAddress       String?  @map("formatted_address")
  useOrganizationAddress Boolean  @default(false) @map("use_organization_address")

  invoices   Invoice[]
  quotes     Quote[]
  emailAudit EmailAudit[]

  @@index([status])
  @@index([email])
  @@index([organizationId])
  @@index([createdAt])
  @@index([status, deletedAt])
  @@map(name: "customers")
}

model Organization {
  id        String     @id @default(cuid())
  name      String
  address   String?
  city      String?
  state     States?
  postcode  String?
  country   String?    @default("Australia")
  customers Customer[]
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt DateTime   @updatedAt @map("updated_at") @db.Timestamptz()

  @@index([name])
  @@map(name: "organizations")
}

model Employee {
  id        String         @id @default(cuid())
  firstName String         @map(name: "first_name")
  lastName  String         @map(name: "last_name")
  email     String         @unique
  phone     String
  gender    Gender?
  dob       DateTime?      @db.Date()
  rate      Decimal        @default(0) @db.Decimal(15, 2)
  status    EmployeeStatus @default(ACTIVE)
  avatarUrl String?        @map(name: "avatar_url")
  createdAt DateTime       @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime       @default(now()) @updatedAt @map(name: "updated_at") @db.Timestamptz()

  @@index([email])
  @@map(name: "employees")
}

model Audit {
  id        String     @id @default(uuid())
  userId    String?    @map(name: "user_id")
  tag       String
  event     String
  message   String
  data      Json?
  level     AuditLevel @default(INFO) // INFO | WARN | ERROR
  createdAt DateTime   @default(now()) @map(name: "created_at") @db.Timestamptz()

  @@map(name: "audit")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map(name: "session_token")
  userId       String   @map(name: "user_id")
  expires      DateTime @db.Timestamptz()

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  ipAddress String? @map(name: "ip_address") @db.Text
  userAgent String? @map(name: "user_agent") @db.Text
  isActive  Boolean @default(true) @map(name: "is_active")

  deviceName     String? @map(name: "device_name")
  deviceType     String? @map(name: "device_type")
  deviceVendor   String? @map(name: "device_vendor")
  deviceModel    String? @map(name: "device_model")
  osName         String? @map(name: "os_name")
  osVersion      String? @map(name: "os_version")
  browserName    String? @map(name: "browser_name")
  browserVersion String? @map(name: "browser_version")
  country        String?
  region         String?
  city           String?
  latitude       Float?
  longitude      Float?
  timezone       String?

  createdAt    DateTime  @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt    DateTime  @default(now()) @map(name: "updated_at") @db.Timestamptz()
  lastActiveAt DateTime? @map(name: "last_active_at") @db.Timestamptz()

  // Indexes for optimizing common queries
  @@index([userId, isActive]) // For fetching active sessions by user
  @@index([userId, lastActiveAt]) // For cleanup and activity tracking
  @@index([expires, isActive]) // For finding expired sessions
  @@index([isActive, lastActiveAt]) // For auto-cleanup job
  @@map(name: "sessions")
}

model Invoice {
  id            String @id @default(cuid())
  invoiceNumber String @unique @map(name: "invoice_number")

  customerId String   @map(name: "customer_id")
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Restrict)

  status InvoiceStatus @default(DRAFT)

  amount     Decimal  @db.Decimal(15, 2)
  amountPaid Decimal  @default(0) @map(name: "amount_paid") @db.Decimal(15, 2)
  amountDue  Decimal  @default(0) @map(name: "amount_due") @db.Decimal(15, 2)
  currency   String   @default("AUD") 
  gst        Decimal  @default(10) @db.Decimal(5, 2)
  discount   Decimal  @default(0) @db.Decimal(15, 2)
  issuedDate DateTime @map(name: "issued_date") @db.Date
  dueDate    DateTime @map(name: "due_date") @db.Date

  remindersSent Int? @default(0) @map(name: "reminders_sent")

  paidDate      DateTime? @map(name: "paid_date") @db.Date
  paymentMethod String?   @map(name: "payment_method")
  receiptNumber String?   @unique @map(name: "receipt_number")

  cancelledDate DateTime? @map(name: "cancelled_date") @db.Date
  cancelReason  String?   @map(name: "cancel_reason")

  notes String? @db.Text

  items         InvoiceItem[]
  payments      Payment[]
  statusHistory InvoiceStatusHistory[]
  emailAudit    EmailAudit[]
  documents     Document[]
  transactions  Transaction[]

  createdAt DateTime  @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime  @updatedAt @map(name: "updated_at") @db.Timestamptz()
  deletedAt DateTime? @map(name: "deleted_at") @db.Timestamptz()

  @@index([customerId])
  @@index([status])
  @@index([issuedDate])
  @@index([status, deletedAt]) // Composite index for filtered queries
  @@index([receiptNumber])     // Index for receipt lookups
  @@index([customerId, status]) // Composite for customer-specific status queries
  @@index([dueDate])            // Index for overdue calculations and sorting
  @@map(name: "invoices")
}

model InvoiceItem {
  id String @id @default(cuid())

  invoiceId String  @map(name: "invoice_id")
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  description String
  quantity    Int
  unitPrice   Decimal @map(name: "unit_price") @db.Decimal(15, 2)
  total       Decimal @db.Decimal(15, 2)

  productId String?  @map(name: "product_id")
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map(name: "updated_at") @db.Timestamptz()

  @@index([invoiceId])
  @@index([productId])  // Product-based queries
  @@map(name: "invoice_items")
}

model InvoiceStatusHistory {
  id             String        @id @default(cuid())
  invoiceId      String        @map(name: "invoice_id")
  invoice        Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  status         InvoiceStatus
  previousStatus InvoiceStatus?
  updatedAt      DateTime      @default(now()) @map(name: "updated_at") @db.Timestamptz()
  updatedBy      String?       @map(name: "updated_by")
  user           User?         @relation("user", fields: [updatedBy], references: [id], onDelete: SetNull)
  notes          String?       @db.Text

  @@index([invoiceId, updatedAt])
  @@index([updatedBy])
  @@map(name: "invoice_status_history")
}

model Payment {
  id String @id @default(cuid())

  invoiceId String  @map(name: "invoice_id")
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  amount    Decimal   @db.Decimal(15, 2)
  date      DateTime  @db.Date
  method    String
  reference String?
  notes     String?   @db.Text
  
  idempotencyKey String? @unique @map(name: "idempotency_key") // Prevents duplicate payments

  createdAt DateTime @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map(name: "updated_at") @db.Timestamptz()

  @@index([invoiceId])
  @@index([invoiceId, date])  // Payment history queries
  @@map(name: "payments")
}

model Quote {
  id          String   @id @default(cuid())
  quoteNumber String   @unique @map(name: "quote_number")
  customerId  String   @map(name: "customer_id")
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Restrict)

  status QuoteStatus @default(DRAFT)

  versionNumber   Int     @default(1) @map(name: "version_number")
  parentQuoteId   String? @map(name: "parent_quote_id")
  parentQuote     Quote?  @relation("QuoteVersions", fields: [parentQuoteId], references: [id], onDelete: Restrict)
  versions        Quote[] @relation("QuoteVersions")
  isLatestVersion Boolean @default(true) @map(name: "is_latest_version")

  amount     Decimal  @db.Decimal(15, 2)
  currency   String   @default("AUD")
  gst        Decimal  @default(10) @db.Decimal(5, 2)
  discount   Decimal  @default(0) @db.Decimal(15, 2)
  issuedDate DateTime @map(name: "issued_date") @db.Date
  validUntil DateTime @map(name: "valid_until") @db.Date

  invoiceId String? @unique @map(name: "invoice_id")
  notes String? @db.Text
  terms String? @db.Text

  items         QuoteItem[]
  documents     Document[]
  statusHistory QuoteStatusHistory[]
  emailAudit    EmailAudit[]

  createdAt DateTime  @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime  @updatedAt @map(name: "updated_at") @db.Timestamptz()
  deletedAt DateTime? @map(name: "deleted_at") @db.Timestamptz()

  @@index([customerId])
  @@index([status])
  @@index([issuedDate])
  @@index([customerId, status])           
  @@index([status, deletedAt])            
  @@index([validUntil])                   
  @@index([parentQuoteId])                
  @@index([customerId, issuedDate(sort: Desc)])
  @@index([deletedAt])                    
  @@index([isLatestVersion, deletedAt])   
  @@index([status, isLatestVersion, deletedAt])
  @@map(name: "quotes")
}

model QuoteItem {
  id      String @id @default(cuid())
  quoteId String @map(name: "quote_id")
  quote   Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  description String
  quantity    Int
  unitPrice   Decimal @map(name: "unit_price") @db.Decimal(15, 2)
  total       Decimal @db.Decimal(15, 2)
  order       Int     @default(0) // Display order within the quote

  // Optional product reference
  productId String?  @map(name: "product_id")
  product   Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  // Item-level attachments (flower arrangement photos)
  attachments QuoteItemAttachment[]

  // Color palette (array of hex color codes, max 10 colors)
  colors String[] @default([])

  // Notes for this quote item (describing the images/attachments)
  notes String? @db.Text

  createdAt DateTime @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map(name: "updated_at") @db.Timestamptz()

  @@index([quoteId])
  @@index([quoteId, order])
  @@index([productId])  // Product-based queries
  @@map(name: "quote_items")
}

model QuoteItemAttachment {
  id          String    @id @default(cuid())
  quoteItemId String    @map(name: "quote_item_id")
  quoteItem   QuoteItem @relation(fields: [quoteItemId], references: [id], onDelete: Cascade)

  fileName String @map(name: "file_name")
  fileSize Int    @map(name: "file_size")
  mimeType String @map(name: "mime_type")
  s3Key    String @map(name: "s3_key")
  s3Url    String @map(name: "s3_url")

  uploadedBy String?  @map(name: "uploaded_by")
  uploadedAt DateTime @default(now()) @map(name: "uploaded_at") @db.Timestamptz()

  @@index([quoteItemId])
  @@index([s3Key])
  @@map(name: "quote_item_attachments")
}

model QuoteStatusHistory {
  id             String      @id @default(cuid())
  quoteId        String      @map(name: "quote_id")
  quote          Quote       @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  status         QuoteStatus
  previousStatus QuoteStatus?
  updatedAt      DateTime    @default(now()) @map(name: "updated_at") @db.Timestamptz()
  updatedBy      String?     @map(name: "updated_by")
  user           User?       @relation("user", fields: [updatedBy], references: [id], onDelete: SetNull)
  notes          String?     @db.Text

  @@index([quoteId, updatedAt])
  @@index([updatedBy])
  @@map(name: "quote_status_history")
}

model Document {
  id String @id @default(cuid())

  kind DocumentKind @map("kind")

  invoiceId String?  @map("invoice_id")
  invoice   Invoice? @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  quoteId String? @map("quote_id")
  quote   Quote?  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  fileHash String @map("file_hash")
  fileName String @map("file_name")
  fileSize Int    @map("file_size")
  mimeType String @default("application/pdf") @map("mime_type")
  s3Key    String @unique @map("s3_key")
  s3Url    String @map("s3_url")

  generatedAt    DateTime @default(now()) @map("generated_at") @db.Timestamptz()
  lastAccessedAt DateTime @default(now()) @map("last_accessed_at") @db.Timestamptz()

  metadata Json?

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz()

  @@index([invoiceId])
  @@index([quoteId])
  @@index([kind])  // Document type filtering
  @@map("documents")
}

model EmailAudit {
  id String @id @default(cuid())

  // Polymorphic relations - can be associated with different entities
  invoiceId  String?   @map("invoice_id")
  invoice    Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  quoteId    String?   @map("quote_id")
  quote      Quote?    @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  customerId String?   @map("customer_id")
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  // Email details
  emailType    String  @map("email_type")     // 'invoice', 'quote', 'reminder', 'receipt', 'report', etc.
  templateName String  @map("template_name")  // Email template used
  recipient    String                         // Email address
  subject      String

  // Email status tracking
  status       EmailStatus @default(QUEUED)
  queuedAt     DateTime    @default(now()) @map("queued_at") @db.Timestamptz()
  sentAt       DateTime?   @map("sent_at") @db.Timestamptz()
  failedAt     DateTime?   @map("failed_at") @db.Timestamptz()

  // Error tracking
  errorMessage String? @map("error_message") @db.Text
  retryCount   Int     @default(0) @map("retry_count")

  // Inngest metadata for cross-referencing
  inngestEventId String? @map("inngest_event_id")
  inngestRunId   String? @map("inngest_run_id")

  // Additional metadata (attachments info, custom data, etc.)
  metadata Json?

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz()

  @@index([invoiceId])
  @@index([quoteId])
  @@index([customerId])
  @@index([status])
  @@index([emailType])
  @@index([queuedAt])
  @@index([inngestEventId])
  @@map("email_audit")
}

model ScheduledTask {
  id        String   @id @default(cuid())

  // Function metadata (synced from code)
  functionId   String   @unique @map("function_id")
  functionName String   @map("function_name")
  description  String?

  // Execution configuration
  isEnabled    Boolean  @default(true) @map("is_enabled")
  scheduleType ScheduleType @default(CRON) @map("schedule_type")
  cronSchedule String?  @map("cron_schedule")
  eventName    String?  @map("event_name")

  // Retry & concurrency configuration
  retries         Int?     @default(0)
  concurrencyLimit Int?    @default(1) @map("concurrency_limit")
  timeout         Int?

  // Metadata
  category     TaskCategory @default(SYSTEM)
  metadata     Json?

  // Sync tracking
  lastSyncedAt DateTime  @default(now()) @map("last_synced_at") @db.Timestamptz()
  codeVersion  String?   @map("code_version")

  // Audit
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz()

  executions TaskExecution[]

  @@index([functionId])
  @@index([isEnabled])
  @@index([category])
  @@index([scheduleType])
  @@map("scheduled_tasks")
}

model TaskExecution {
  id String @id @default(cuid())

  taskId String @map("task_id")
  task   ScheduledTask @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Execution tracking
  status         ExecutionStatus @default(RUNNING)
  triggeredBy    TriggerSource   @default(SCHEDULE) @map("triggered_by")
  triggeredByUser String?        @map("triggered_by_user")
  user           User?           @relation(fields: [triggeredByUser], references: [id], onDelete: SetNull)

  // Inngest cross-reference
  inngestRunId   String?  @unique @map("inngest_run_id")
  inngestEventId String?  @map("inngest_event_id")

  // Timing
  startedAt   DateTime  @default(now()) @map("started_at") @db.Timestamptz()
  completedAt DateTime? @map("completed_at") @db.Timestamptz()
  duration    Int?

  // Results
  result       Json?
  error        String?   @db.Text
  stackTrace   String?   @map("stack_trace") @db.Text
  retryCount   Int       @default(0) @map("retry_count")

  // Step-level logs
  steps        Json?

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz()

  @@index([taskId])
  @@index([taskId, startedAt(sort: Desc)])
  @@index([status])
  @@index([inngestRunId])
  @@index([startedAt])
  @@map("task_executions")
}

model Transaction {
  id          String            @id @default(cuid())
  type        TransactionType
  date        DateTime          @db.Date
  amount      Decimal           @db.Decimal(15, 2)
  currency    String            @default("USD")
  description String
  payee       String
  status          TransactionStatus                 @default(COMPLETED)
  referenceNumber String                           @unique @map(name: "reference_number")
  referenceId     String?                           @map(name: "reference_id")
  invoiceId   String?           @map(name: "invoice_id")
  invoice     Invoice?          @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  categories  TransactionCategoryOnTransaction[]
  attachments TransactionAttachment[]

  createdAt DateTime @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt DateTime @updatedAt @map(name: "updated_at") @db.Timestamptz()

  @@index([type])
  @@index([status])
  @@index([date], map: "transactions_date_idx")
  @@index([invoiceId])
  @@index([type, status])
  @@index([date(sort: Desc)], map: "transactions_date_desc_idx")
  @@map(name: "transactions")
}

model TransactionCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true) @map(name: "is_active")
  createdAt   DateTime @default(now()) @map(name: "created_at") @db.Timestamptz()
  updatedAt   DateTime @updatedAt @map(name: "updated_at") @db.Timestamptz()

  transactions TransactionCategoryOnTransaction[]

  @@map(name: "transaction_categories")
}

model TransactionCategoryOnTransaction {
  transactionId String              @map(name: "transaction_id")
  transaction   Transaction         @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  
  categoryId    String              @map(name: "category_id")
  category      TransactionCategory @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  
  assignedAt    DateTime            @default(now()) @map(name: "assigned_at") @db.Timestamptz()

  @@id([transactionId, categoryId])
  @@index([transactionId])
  @@index([categoryId])
  @@map(name: "transaction_category_on_transaction")
}

model TransactionAttachment {
  id            String      @id @default(cuid())
  transactionId String      @map(name: "transaction_id")
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  fileName String @map(name: "file_name")
  fileSize Int    @map(name: "file_size")
  mimeType String @map(name: "mime_type")
  s3Key    String @map(name: "s3_key")
  s3Url    String @map(name: "s3_url")

  uploadedBy String?  @map(name: "uploaded_by")
  uploadedAt DateTime @default(now()) @map(name: "uploaded_at") @db.Timestamptz()

  @@index([transactionId])
  @@index([s3Key])
  @@map(name: "transaction_attachments")
}

enum Gender {
  MALE
  FEMALE
}

enum EmployeeStatus {
  ACTIVE
  INACTIVE
}

enum CustomerStatus {
  ACTIVE
  INACTIVE
  DELETED
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum States {
  ACT
  NSW
  NT
  QLD
  SA
  TAS
  VIC
  WA
}

enum AuditLevel {
  INFO
  WARN
  ERROR
}

enum InvoiceStatus {
  PENDING
  PAID
  PARTIALLY_PAID
  CANCELLED
  OVERDUE
  DRAFT
}

enum QuoteStatus {
  DRAFT
  SENT
  ON_HOLD
  ACCEPTED
  REJECTED
  EXPIRED
  CANCELLED
  CONVERTED
}

enum DocumentKind {
  INVOICE
  RECEIPT
  QUOTE
}

enum EmailStatus {
  QUEUED
  SENDING
  SENT
  FAILED
  RETRYING
}

enum UserRole {
  ADMIN
  MANAGER
  USER
}

enum ScheduleType {
  CRON
  EVENT
  HYBRID
}

enum TaskCategory {
  SYSTEM
  EMAIL
  CLEANUP
  FINANCE
  CUSTOM
}

enum ExecutionStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT
}

enum TriggerSource {
  SCHEDULE
  MANUAL
  EVENT
  RETRY
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  CANCELLED
}

